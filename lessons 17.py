# рекурсия и динамическое программирование

def f(n: int) -> int:
    """
    факториал рекурсией
    :param n:
    :return:
    """
    if n == 0:
        return 1
    return f(n - 1) * n


a = f(5)
print(a)

# факториал циклом
n = 5
q = [1] * (n + 1)  # резервируем нужное количество места в памяти для числа
for i in range(1, n + 1):
    q[i] = q[i - 1] * i
print(q[5])


# числа Фибоначи

def fib(n: int) -> int:
    """
    число Фибоначи рекурсией
    :param n:
    :return:
    """
    assert n >= 0  # только для положительных целых числов
    if n <= 1:
        return n
    else:
        return fib(n - 1) + fib(n - 2)


def fib2(n: int) -> int:
    """
    число Фибоначи циклом
    :param n:
    :return:
    """
    assert n >= 0  # только для положительных целых числов
    fib = [None] * (n + 1)  # резервируем нужное количество места в памяти для числа
    fib[:2] = [0, 1]
    for k in range(2, n + 1):
        fib[k] = fib[k - 1] + fib[k - 2]
    return fib[n]


# число Фибоначи рекурсией с хешированием
F = [None] * 10000  # резервируем для рекурсии место


def fib3(n: int) -> int:
    """
    число Фибоначи рекурсией с хешированием
    :param n:
    :return:
    """
    assert (n >= 0 and n < 10000)  # только для положительных целых числов и
    # глубино рекурси 10000( больше python не позволит улубиться)
    if F[n] is None:
        if n <= 1:
            F[n] = n
        else:
            F[n] = fib3(n - 1) + fib3(n - 2)
    return F[n]


print(fib3(40))

# задача рюкзака методом динамического программирования
N = 3  # N-количество предметов
m = [0, 1, 3, 4]  # вес предметов
v = [0, 1500, 2000, 3000]  # стоймость предметов
M = 4  # максимальная вес рюкзака
D = [[0] * (N + 1) for i in range(M + 1)]  # двумерный массив  где N-количество предметов М - вес
for i in range(1, N + 1):
    for k in range(1, M + 1):
        if m[i] <= k:
            D[k][i] = max(D[k][i - 1], v[i] + D[k - m[i]][i-1])
        else:
            D[k][i] = D[k][i - 1]

print(D[M][N])
